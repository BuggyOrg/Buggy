//- semantics.jade
extends ../includes/base.jade
append navbar
  - var chapter = "Compose"
  - var section = "Semantics"
append content
  h3.heading Semantics
  p
    | The Semantics in Buggy describe the actual functionality on different
    | levels. This is done to achieve a high abstraction from the actual
    | implementation. The overall goal is to create a description of a problem
    | that is on a high abstraction level and must not necessary contain
    | information about how to takle the problem or corresponding problems
    | on lower abstraction levels. You should be able to describe the problem
    | in a short manner without switching the abstraction level.
  p
    | Buggy introduces a variety of Semantic Fields for this purpose that
    | can introduce an high level of abstraction. The Semantic information of
    | all these field can be queried during the Compose process. This
    | information is stored locally and distributed, meaning that it is
    | possible to use only the local set of Semantic information but you
    | can also access Semantic information stored and maintained somewhere
    | else
  .ui.accordion.caution.fluid.inverted.green
    .title
      i.icon.dropdown
      | Storing Semantic information
    .content
      | Buggy does not enforce a specific storage format. Semantic information
      | be stored in any way. But in order to use it in Buggy the resulting
      | format must be JSON. This article describes how the core implementation
      | accesses and stores the information in multiple files. The interface
      | for the semantics is a simple query routine explained later.
  h3.heading
    | Semantic Fields
    a(source-ref="Semantic Field").sourcelink
      i.icon.code
  p
    | Buggy distinguishes between different Semantic Fields that are each
    | responsible for a specific task. The main Semantic Fields are:
    .ui.fluid.accordion
      .title
        i.icon.dropdown
        | Symbols
        a(source-ref="Semantic Field/Symbols").sourcelink.inline
          i.icon.code
      .content
        | Defines what functionality exists without the information how
        | this functionality is implemented.
        a(href="#symbols") &nbsp;More
          i.icon.double.angle.right
        br
        .tiny.ui.horizontal.bulleted.list.right
          i.item
            a(source-ref="Semantic Field/Symbols/Predicates").sourcelink.list Predicates:
              i.icon.code
        br
      .title
        i.icon.dropdown
        | Implementations
        a(source-ref="Semantic Field/Implementations").sourcelink.inline
          i(title="Bla").icon.code.linkpopup
      .content
        | Defines ways of implementing known Symbols. There can be multiple
        | implementations for only one Symbol.
        a(href="#implementations") &nbsp;More
          i.icon.double.angle.right
        br
        .tiny.ui.horizontal.bulleted.list.right
          i.item
            a(source-ref="Semantic Field/Implementations/Hooks").sourcelink.list Hooks:
              i.icon.code
          i.item
            a(source-ref="Semantic Field/Implementations/Predicates").sourcelink.list Predicates:
              i.icon.code
        br
      .title
        i.icon.dropdown
        | Construction Rules
        a(source-ref="Semantic Field/Construction").sourcelink.list
          i.icon.code
      .content
        | Describes how to build actual programs with implemented symbols.
        | This part doesn't introduce any actual functionality it is
        | responsible for the necessary boilerplate code.
        a(href="#construction") &nbsp;More
          i.icon.double.angle.right
        br
        .tiny.ui.horizontal.bulleted.list.right
          i.item
            a(source-ref="Semantic Field/Construction/Hooks").sourcelink.list Hooks:
              i.icon.code
          i.item
            a(source-ref="Semantic Field/Construction/Predicates").sourcelink.list Predicates:
              i.icon.code
        br

  .ui.accordion.caution.fluid.inverted.green
    .title
      i.icon.dropdown
      | Creating new Semantic Fields
    .content
      | The Semantic Fields are implemented using a Hooks / Predicate system
      | where:
      ul
        li.item
          b Hooks&nbsp;
          | can change, extend, etc. a Field when it is added.
        li.item
          b Predicates&nbsp;
          | implement how a query to the Field is processed on the data.
  .ui.accordion.caution.fluid.inverted.red
    .ui.corner.label
      i.icon.exclamation
    .title
      i.icon.dropdown
      | Caution! Creating new Semantic Fields
    .content
      | When creating Hooks / Predicates with LiveScript be cautios, the Syntax used for
      | lists in the existing Hooks / Predicates only works when you have more
      | then one element. You have to explicitly mark the list as an array by
      | surrounding it with <code>[]</code> when there is only one element in it.
      | Like in the following example
      .ui.segment.inverted
        pre
          code
            | Predicates = [
            | * name: "name filter",
            |   description: "filters all elements that don't match the given name",
            |   process: (value, query, options)->
            |     value.name == query
            | ]
  h3(id="symbols").heading Symbols
    a(source-ref="Semantic Field/Symbols").sourcelink
      i.icon.code
  p
    | A Symbol describes a procedure. This can be a simple thing like
    i Add
    | or a complex Problem like the
    i Travelling Salesman Problem
    | . The Symbol does not describe how to calculate a solution or even how
    | To approach the problem. It rather states what data will be processed.
    | For an Add this can be two Numbers going and one resulting number going
    | out, the Sum. A Symbol does not specify the exact semantics of the
    | problem. There might be different interpretations of an problem and
    | thus the exact semantics are chosen later with
    a(href="#") &nbsp;semantic tests&nbsp;
    | and via user specifications and other methods.
  p
    | A Symbol always looks has a name and it can have connectors. The
    | corresponding JSON Object looks like this.
    .ui.segment.inverted
      pre
        code
          | {
          |  "name" : "Add",
          |  "connectors" : [
          |    { "name" : "Term 1", "type" : "Input" },
          |    { "name" : "Term 2", "type" : "Input" },
          |    { "name" : "Sum", "type" : "Output" }
          |  ]
          | },
    .ui.accordion.fluid.fluid.inverted.purple
      .title
        i.icon.dropdown
        | Work in progress: Connectors for Main Node.
      .content
        | Every Symbol should probably have at least one connector. Currently the
        | main node has no connector. The main node represents the starting point
        | of a program. It is unclear weather the main node needs any connection
        | at all. Inputs to a program are made through input nodes and outputs
        | via output nodes. They are probably more adaptable than connectors.
    .ui.accordion.fluid.fluid.inverted.purple
      .title
        i.icon.dropdown
        | Work in progress: Datatypes.
      .content
        | There is no support for any datatype yet. This will be added in the
        | and might influence the above notation!
  h3(id="implementations").heading Implementations
    a(source-ref="Semantic Field/Implementations").sourcelink
      i.icon.code
  p
    | ...
